//! Trading Signal Types
//!
//! This module defines the signal types used by trading strategies to communicate
//! entry and exit intentions. Signals are generated by strategies and consumed by
//! the trading engine or backtest engine.
//!
//! Design principles:
//! - Type-safe signal types with compile-time validation
//! - Rich metadata for signal reasoning and debugging
//! - Strength-based signals for confidence levels
//! - Memory-efficient with minimal allocations

const std = @import("std");
const Decimal = @import("../root.zig").Decimal;
const Timestamp = @import("../root.zig").Timestamp;
const TradingPair = @import("../root.zig").TradingPair;
const Side = @import("../root.zig").Side;

// ============================================================================
// Signal Type
// ============================================================================

/// Trading signal type
/// Represents the intended action for a trading strategy
pub const SignalType = enum {
    entry_long,  // Open long position (buy)
    entry_short, // Open short position (sell)
    exit_long,   // Close long position (sell)
    exit_short,  // Close short position (buy to cover)
    hold,        // No action, maintain current state

    /// Check if signal is an entry signal
    pub fn isEntry(self: SignalType) bool {
        return self == .entry_long or self == .entry_short;
    }

    /// Check if signal is an exit signal
    pub fn isExit(self: SignalType) bool {
        return self == .exit_long or self == .exit_short;
    }

    /// Check if signal requires action
    pub fn requiresAction(self: SignalType) bool {
        return self != .hold;
    }

    /// Convert to string representation
    pub fn toString(self: SignalType) []const u8 {
        return switch (self) {
            .entry_long => "ENTRY_LONG",
            .entry_short => "ENTRY_SHORT",
            .exit_long => "EXIT_LONG",
            .exit_short => "EXIT_SHORT",
            .hold => "HOLD",
        };
    }

    /// Get the trading side for this signal
    pub fn toSide(self: SignalType) ?Side {
        return switch (self) {
            .entry_long => .buy,
            .entry_short => .sell,
            .exit_long => .sell,
            .exit_short => .buy,
            .hold => null,
        };
    }
};

// ============================================================================
// Signal Metadata
// ============================================================================

/// Indicator value used in signal reasoning
pub const IndicatorValue = struct {
    name: []const u8,
    value: Decimal,
};

/// Signal metadata containing reasoning and context
pub const SignalMetadata = struct {
    reason: []const u8,                      // Human-readable reason for signal
    indicators: []const IndicatorValue,      // Indicator values at signal time
    allocator: std.mem.Allocator,

    /// Initialize signal metadata
    pub fn init(
        allocator: std.mem.Allocator,
        reason: []const u8,
        indicators: []const IndicatorValue,
    ) !SignalMetadata {
        const reason_copy = try allocator.dupe(u8, reason);
        errdefer allocator.free(reason_copy);

        const indicators_copy = try allocator.dupe(IndicatorValue, indicators);

        return SignalMetadata{
            .reason = reason_copy,
            .indicators = indicators_copy,
            .allocator = allocator,
        };
    }

    /// Free allocated memory
    pub fn deinit(self: SignalMetadata) void {
        self.allocator.free(self.reason);
        self.allocator.free(self.indicators);
    }
};

// ============================================================================
// Trading Signal
// ============================================================================

/// Trading signal
/// Represents a trading decision made by a strategy at a specific point in time
pub const Signal = struct {
    /// Signal type (entry/exit/hold)
    type: SignalType,

    /// Trading pair
    pair: TradingPair,

    /// Trading side
    side: Side,

    /// Suggested price for execution
    price: Decimal,

    /// Signal strength [0.0, 1.0]
    /// 0.0 = weakest, 1.0 = strongest
    strength: f64,

    /// Signal timestamp
    timestamp: Timestamp,

    /// Optional metadata with reasoning
    metadata: ?SignalMetadata,

    /// Initialize a new signal
    pub fn init(
        signal_type: SignalType,
        pair: TradingPair,
        side: Side,
        price: Decimal,
        strength: f64,
        timestamp: Timestamp,
        metadata: ?SignalMetadata,
    ) !Signal {
        // Validate strength is in [0.0, 1.0]
        if (strength < 0.0 or strength > 1.0) {
            return error.InvalidSignalStrength;
        }

        return Signal{
            .type = signal_type,
            .pair = pair,
            .side = side,
            .price = price,
            .strength = strength,
            .timestamp = timestamp,
            .metadata = metadata,
        };
    }

    /// Free allocated memory
    pub fn deinit(self: Signal) void {
        if (self.metadata) |metadata| {
            metadata.deinit();
        }
    }

    /// Validate signal consistency
    pub fn validate(self: Signal) !void {
        // Check strength range
        if (self.strength < 0.0 or self.strength > 1.0) {
            return error.InvalidSignalStrength;
        }

        // Check price is positive
        if (!self.price.isPositive()) {
            return error.InvalidSignalPrice;
        }

        // Check signal type and side consistency
        const expected_side = self.type.toSide();
        if (expected_side) |expected| {
            if (self.side != expected) {
                return error.SignalTypeSideMismatch;
            }
        }
    }

    /// Check if signal is valid
    pub fn isValid(self: Signal) bool {
        return self.strength >= 0.0 and self.strength <= 1.0 and
            self.price.isPositive();
    }

    /// Check if signal is strong (strength >= 0.7)
    pub fn isStrong(self: Signal) bool {
        return self.strength >= 0.7;
    }

    /// Check if signal is weak (strength < 0.3)
    pub fn isWeak(self: Signal) bool {
        return self.strength < 0.3;
    }
};

// ============================================================================
// Tests
// ============================================================================

test "SignalType: isEntry and isExit" {
    try std.testing.expect(SignalType.entry_long.isEntry());
    try std.testing.expect(SignalType.entry_short.isEntry());
    try std.testing.expect(!SignalType.entry_long.isExit());
    try std.testing.expect(!SignalType.entry_short.isExit());

    try std.testing.expect(SignalType.exit_long.isExit());
    try std.testing.expect(SignalType.exit_short.isExit());
    try std.testing.expect(!SignalType.exit_long.isEntry());
    try std.testing.expect(!SignalType.exit_short.isEntry());

    try std.testing.expect(!SignalType.hold.isEntry());
    try std.testing.expect(!SignalType.hold.isExit());
}

test "SignalType: requiresAction" {
    try std.testing.expect(SignalType.entry_long.requiresAction());
    try std.testing.expect(SignalType.entry_short.requiresAction());
    try std.testing.expect(SignalType.exit_long.requiresAction());
    try std.testing.expect(SignalType.exit_short.requiresAction());
    try std.testing.expect(!SignalType.hold.requiresAction());
}

test "SignalType: toString" {
    try std.testing.expectEqualStrings("ENTRY_LONG", SignalType.entry_long.toString());
    try std.testing.expectEqualStrings("ENTRY_SHORT", SignalType.entry_short.toString());
    try std.testing.expectEqualStrings("EXIT_LONG", SignalType.exit_long.toString());
    try std.testing.expectEqualStrings("EXIT_SHORT", SignalType.exit_short.toString());
    try std.testing.expectEqualStrings("HOLD", SignalType.hold.toString());
}

test "SignalType: toSide" {
    try std.testing.expectEqual(Side.buy, SignalType.entry_long.toSide().?);
    try std.testing.expectEqual(Side.sell, SignalType.entry_short.toSide().?);
    try std.testing.expectEqual(Side.sell, SignalType.exit_long.toSide().?);
    try std.testing.expectEqual(Side.buy, SignalType.exit_short.toSide().?);
    try std.testing.expect(SignalType.hold.toSide() == null);
}

test "SignalMetadata: init and deinit" {
    const allocator = std.testing.allocator;

    const indicators = [_]IndicatorValue{
        .{ .name = "sma_20", .value = Decimal.fromInt(50000) },
        .{ .name = "rsi_14", .value = Decimal.fromInt(65) },
    };

    const metadata = try SignalMetadata.init(
        allocator,
        "SMA crossover detected",
        &indicators,
    );
    defer metadata.deinit();

    try std.testing.expectEqualStrings("SMA crossover detected", metadata.reason);
    try std.testing.expectEqual(@as(usize, 2), metadata.indicators.len);
    try std.testing.expectEqualStrings("sma_20", metadata.indicators[0].name);
}

test "Signal: create valid signal" {
    const signal = try Signal.init(
        .entry_long,
        .{ .base = "BTC", .quote = "USDT" },
        .buy,
        Decimal.fromInt(50000),
        0.8,
        Timestamp.now(),
        null,
    );
    defer signal.deinit();

    try std.testing.expect(signal.isValid());
    try std.testing.expectEqual(SignalType.entry_long, signal.type);
    try std.testing.expectEqual(Side.buy, signal.side);
    try std.testing.expectEqual(@as(f64, 0.8), signal.strength);
}

test "Signal: reject invalid strength" {
    const result = Signal.init(
        .entry_long,
        .{ .base = "BTC", .quote = "USDT" },
        .buy,
        Decimal.fromInt(50000),
        1.5, // Invalid: > 1.0
        Timestamp.now(),
        null,
    );

    try std.testing.expectError(error.InvalidSignalStrength, result);
}

test "Signal: strength classification" {
    const strong = try Signal.init(
        .entry_long,
        .{ .base = "BTC", .quote = "USDT" },
        .buy,
        Decimal.fromInt(50000),
        0.9,
        Timestamp.now(),
        null,
    );
    try std.testing.expect(strong.isStrong());
    try std.testing.expect(!strong.isWeak());

    const weak = try Signal.init(
        .entry_long,
        .{ .base = "BTC", .quote = "USDT" },
        .buy,
        Decimal.fromInt(50000),
        0.2,
        Timestamp.now(),
        null,
    );
    try std.testing.expect(!weak.isStrong());
    try std.testing.expect(weak.isWeak());
}

test "Signal: validation - type and side mismatch" {
    // entry_long should have side = buy
    const valid = try Signal.init(
        .entry_long,
        .{ .base = "BTC", .quote = "USDT" },
        .buy,
        Decimal.fromInt(50000),
        0.8,
        Timestamp.now(),
        null,
    );
    try valid.validate();

    // entry_long with side = sell should fail
    const invalid = try Signal.init(
        .entry_long,
        .{ .base = "BTC", .quote = "USDT" },
        .sell, // Wrong side!
        Decimal.fromInt(50000),
        0.8,
        Timestamp.now(),
        null,
    );
    try std.testing.expectError(error.SignalTypeSideMismatch, invalid.validate());
}

test "Signal: no memory leak with metadata" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer {
        const leaked = gpa.deinit();
        if (leaked == .leak) {
            @panic("Memory leak detected!");
        }
    }
    const allocator = gpa.allocator();

    const indicators = [_]IndicatorValue{
        .{ .name = "sma_20", .value = Decimal.fromInt(50000) },
    };

    const metadata = try SignalMetadata.init(
        allocator,
        "Test signal",
        &indicators,
    );

    const signal = try Signal.init(
        .entry_long,
        .{ .base = "BTC", .quote = "USDT" },
        .buy,
        Decimal.fromInt(50000),
        0.8,
        Timestamp.now(),
        metadata,
    );
    defer signal.deinit();

    _ = signal.isValid();
}
