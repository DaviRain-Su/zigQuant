# v0.3.0 ç­–ç•¥æ¡†æ¶è®¾è®¡æ–‡æ¡£

**ç‰ˆæœ¬**: v0.3.0
**åˆ›å»ºæ—¥æœŸ**: 2025-12-25
**çŠ¶æ€**: è®¾è®¡é˜¶æ®µ
**å‚è€ƒæ¡†æ¶**: [Hummingbot V2](https://hummingbot.org/v2-strategies/), [Freqtrade IStrategy](https://www.freqtrade.io/en/stable/strategy-customization/)

---

## ğŸ“‹ ç›®å½•

1. [è®¾è®¡ç›®æ ‡](#è®¾è®¡ç›®æ ‡)
2. [æ¶æ„è®¾è®¡](#æ¶æ„è®¾è®¡)
3. [æ ¸å¿ƒæ¥å£](#æ ¸å¿ƒæ¥å£)
4. [æŠ€æœ¯æŒ‡æ ‡åº“](#æŠ€æœ¯æŒ‡æ ‡åº“)
5. [å†…ç½®ç­–ç•¥](#å†…ç½®ç­–ç•¥)
6. [å›æµ‹å¼•æ“](#å›æµ‹å¼•æ“)
7. [å‚æ•°ä¼˜åŒ–](#å‚æ•°ä¼˜åŒ–)
8. [å®æ–½è®¡åˆ’](#å®æ–½è®¡åˆ’)

---

## ğŸ¯ è®¾è®¡ç›®æ ‡

### é¡¹ç›®ä½¿å‘½ï¼ˆæ¥è‡ª Constitutionï¼‰

> ç»“åˆ **Hummingbot çš„åšå¸‚/å¥—åˆ©èƒ½åŠ›** å’Œ **Freqtrade çš„ç­–ç•¥å›æµ‹/è‡ªåŠ¨äº¤æ˜“èƒ½åŠ›**

### æ ¸å¿ƒç›®æ ‡

1. **æ˜“ç”¨æ€§** - å¼€å‘è€…å¯ä»¥å¿«é€Ÿåˆ›å»ºå’Œæµ‹è¯•ç­–ç•¥
2. **æ¨¡å—åŒ–** - ç­–ç•¥ç»„ä»¶å¯ç‹¬ç«‹å¼€å‘å’Œæµ‹è¯•
3. **é«˜æ€§èƒ½** - Zig çš„é›¶æˆæœ¬æŠ½è±¡å’Œå†…å­˜å®‰å…¨
4. **å¯å›æµ‹** - å†å²æ•°æ®éªŒè¯ç­–ç•¥æ•ˆæœ
5. **å¯ä¼˜åŒ–** - è‡ªåŠ¨å¯»æ‰¾æœ€ä½³å‚æ•°ç»„åˆ

### éåŠŸèƒ½æ€§è¦æ±‚

- **ç±»å‹å®‰å…¨**: ç¼–è¯‘æ—¶æ£€æŸ¥æ‰€æœ‰ç­–ç•¥å‚æ•°
- **é›¶å†…å­˜æ³„æ¼**: GeneralPurposeAllocator éªŒè¯
- **ä½å»¶è¿Ÿ**: ç­–ç•¥æ‰§è¡Œå»¶è¿Ÿ < 1ms
- **å¯æ‰©å±•**: æ”¯æŒè‡ªå®šä¹‰æŒ‡æ ‡å’Œç­–ç•¥

---

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„

å‚è€ƒ Hummingbot V2 çš„æ¨¡å—åŒ–è®¾è®¡å’Œ Freqtrade çš„ IStrategy æ¥å£ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Strategy Framework                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚  â”‚   IStrategy  â”‚â—„â”€â”€â”€â”€â”€â”‚  Strategy    â”‚ (ç”¨æˆ·å®ç°)           â”‚
â”‚  â”‚  Interface   â”‚      â”‚  Impl        â”‚                     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â”‚         â”‚                                                    â”‚
â”‚         â–¼                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚         Strategy Context                 â”‚               â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤               â”‚
â”‚  â”‚  - Market Data Provider                  â”‚               â”‚
â”‚  â”‚  - Indicator Manager                     â”‚               â”‚
â”‚  â”‚  - Order Executor                        â”‚               â”‚
â”‚  â”‚  - Position Manager                      â”‚               â”‚
â”‚  â”‚  - Risk Manager                          â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚         â”‚                                                    â”‚
â”‚         â–¼                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚  Indicator   â”‚  â”‚   Signal     â”‚  â”‚   Executor   â”‚      â”‚
â”‚  â”‚   Library    â”‚  â”‚  Generator   â”‚  â”‚   Engine     â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚         Backtest Engine                â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚  - Historical Data Feed                â”‚
        â”‚  - Event Simulator                     â”‚
        â”‚  - Performance Analyzer                â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### è®¾è®¡åŸåˆ™ï¼ˆå‚è€ƒ Hummingbot V2ï¼‰

1. **æ¾è€¦åˆ**: é€šè¿‡äº‹ä»¶é˜Ÿåˆ—é€šä¿¡
2. **é«˜å†…èš**: æ¯ä¸ªç»„ä»¶èŒè´£å•ä¸€
3. **å¯æµ‹è¯•**: æ‰€æœ‰ç»„ä»¶å¯ç‹¬ç«‹ mock
4. **å¯ç»„åˆ**: Lego å¼ç»„ä»¶æ‹¼æ¥

### ç›®å½•ç»“æ„

```
src/
â”œâ”€â”€ strategy/
â”‚   â”œâ”€â”€ interface.zig           # IStrategy æ¥å£å®šä¹‰
â”‚   â”œâ”€â”€ context.zig             # StrategyContext
â”‚   â”œâ”€â”€ executor.zig            # OrderExecutor
â”‚   â”œâ”€â”€ signal.zig              # SignalGenerator
â”‚   â”œâ”€â”€ risk.zig                # RiskManager
â”‚   â”œâ”€â”€ types.zig               # ç­–ç•¥ç›¸å…³ç±»å‹
â”‚   â”‚
â”‚   â”œâ”€â”€ indicators/             # æŠ€æœ¯æŒ‡æ ‡åº“
â”‚   â”‚   â”œâ”€â”€ sma.zig
â”‚   â”‚   â”œâ”€â”€ ema.zig
â”‚   â”‚   â”œâ”€â”€ rsi.zig
â”‚   â”‚   â”œâ”€â”€ macd.zig
â”‚   â”‚   â”œâ”€â”€ bollinger.zig
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚
â”‚   â””â”€â”€ builtin/                # å†…ç½®ç­–ç•¥
â”‚       â”œâ”€â”€ dual_ma.zig         # åŒå‡çº¿ç­–ç•¥
â”‚       â”œâ”€â”€ mean_reversion.zig  # å‡å€¼å›å½’ç­–ç•¥
â”‚       â””â”€â”€ breakout.zig        # çªç ´ç­–ç•¥
â”‚
â”œâ”€â”€ backtest/
â”‚   â”œâ”€â”€ engine.zig              # å›æµ‹å¼•æ“
â”‚   â”œâ”€â”€ data_feed.zig           # å†å²æ•°æ®æä¾›
â”‚   â”œâ”€â”€ event.zig               # äº‹ä»¶ç³»ç»Ÿ
â”‚   â”œâ”€â”€ analyzer.zig            # æ€§èƒ½åˆ†æ
â”‚   â””â”€â”€ types.zig
â”‚
â””â”€â”€ optimizer/
    â”œâ”€â”€ grid_search.zig         # ç½‘æ ¼æœç´¢
    â”œâ”€â”€ genetic.zig             # é—ä¼ ç®—æ³•ï¼ˆå¯é€‰ï¼‰
    â””â”€â”€ types.zig
```

---

## ğŸ”Œ æ ¸å¿ƒæ¥å£

### IStrategy æ¥å£ï¼ˆå‚è€ƒ Freqtradeï¼‰

```zig
/// ç­–ç•¥æ¥å£ - æ‰€æœ‰ç­–ç•¥å¿…é¡»å®ç°æ­¤æ¥å£
pub const IStrategy = struct {
    ptr: *anyopaque,
    vtable: *const VTable,

    pub const VTable = struct {
        /// åˆå§‹åŒ–ç­–ç•¥
        init: *const fn (*anyopaque, StrategyContext) anyerror!void,

        /// æ¸…ç†èµ„æº
        deinit: *const fn (*anyopaque) void,

        /// è®¡ç®—æŠ€æœ¯æŒ‡æ ‡ï¼ˆç±»ä¼¼ Freqtrade çš„ populate_indicatorsï¼‰
        populateIndicators: *const fn (*anyopaque, *Candles) anyerror!void,

        /// ç”Ÿæˆå…¥åœºä¿¡å·ï¼ˆç±»ä¼¼ Freqtrade çš„ populate_entry_trendï¼‰
        generateEntrySignal: *const fn (*anyopaque, *Candles, usize) anyerror!?Signal,

        /// ç”Ÿæˆå‡ºåœºä¿¡å·ï¼ˆç±»ä¼¼ Freqtrade çš„ populate_exit_trendï¼‰
        generateExitSignal: *const fn (*anyopaque, *Candles, Position) anyerror!?Signal,

        /// ä»“ä½å¤§å°è®¡ç®—
        calculatePositionSize: *const fn (*anyopaque, Signal, Account) anyerror!Decimal,

        /// ç­–ç•¥å‚æ•°ï¼ˆç”¨äºä¼˜åŒ–ï¼‰
        getParameters: *const fn (*anyopaque) []StrategyParameter,

        /// ç­–ç•¥å…ƒæ•°æ®
        getMetadata: *const fn (*anyopaque) StrategyMetadata,
    };

    // ä»£ç†æ–¹æ³•
    pub fn init(self: IStrategy, ctx: StrategyContext) !void {
        return self.vtable.init(self.ptr, ctx);
    }

    pub fn populateIndicators(self: IStrategy, candles: *Candles) !void {
        return self.vtable.populateIndicators(self.ptr, candles);
    }

    pub fn generateEntrySignal(self: IStrategy, candles: *Candles, index: usize) !?Signal {
        return self.vtable.generateEntrySignal(self.ptr, candles, index);
    }

    pub fn generateExitSignal(self: IStrategy, candles: *Candles, pos: Position) !?Signal {
        return self.vtable.generateExitSignal(self.ptr, candles, pos);
    }

    // ... å…¶ä»–ä»£ç†æ–¹æ³•
};
```

### ç­–ç•¥å…ƒæ•°æ®

```zig
/// ç­–ç•¥å…ƒæ•°æ®ï¼ˆå‚è€ƒ Freqtradeï¼‰
pub const StrategyMetadata = struct {
    name: []const u8,
    version: []const u8,
    author: []const u8,
    description: []const u8,

    /// ç­–ç•¥ç±»å‹
    strategy_type: StrategyType,

    /// æ—¶é—´å‘¨æœŸ
    timeframe: Timeframe,

    /// å¯åŠ¨éœ€è¦çš„èœ¡çƒ›æ•°
    startup_candle_count: u32,

    /// æœ€å° ROI ç›®æ ‡ï¼ˆå‚è€ƒ Freqtradeï¼‰
    minimal_roi: MinimalROI,

    /// æ­¢æŸç™¾åˆ†æ¯”ï¼ˆå‚è€ƒ Freqtradeï¼‰
    stoploss: Decimal,

    /// è¿½è¸ªæ­¢æŸé…ç½®ï¼ˆå‚è€ƒ Freqtradeï¼‰
    trailing_stop: ?TrailingStopConfig,
};

/// ç­–ç•¥ç±»å‹
pub const StrategyType = enum {
    trend_following,    // è¶‹åŠ¿è·Ÿéš
    mean_reversion,     // å‡å€¼å›å½’
    breakout,          // çªç ´
    arbitrage,         // å¥—åˆ©ï¼ˆHummingbotï¼‰
    market_making,     // åšå¸‚ï¼ˆHummingbotï¼‰
    grid_trading,      // ç½‘æ ¼äº¤æ˜“
    custom,            // è‡ªå®šä¹‰
};

/// æœ€å° ROI é…ç½®ï¼ˆFreqtrade é£æ ¼ï¼‰
pub const MinimalROI = struct {
    /// æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰ -> ç›®æ ‡æ”¶ç›Šç‡
    targets: []ROITarget,

    pub const ROITarget = struct {
        time_minutes: u32,
        profit_ratio: Decimal,
    };
};

/// è¿½è¸ªæ­¢æŸé…ç½®ï¼ˆFreqtrade é£æ ¼ï¼‰
pub const TrailingStopConfig = struct {
    enabled: bool,
    positive_offset: Decimal,  // æ­£æ”¶ç›Šåæ‰å¯åŠ¨
    only_offset_is_reached: bool,
};
```

### ç­–ç•¥ä¸Šä¸‹æ–‡ï¼ˆå‚è€ƒ Hummingbot Controllerï¼‰

```zig
/// ç­–ç•¥æ‰§è¡Œä¸Šä¸‹æ–‡ - æä¾›ç­–ç•¥æ‰€éœ€çš„æ‰€æœ‰èµ„æº
pub const StrategyContext = struct {
    allocator: std.mem.Allocator,
    logger: Logger,

    /// å¸‚åœºæ•°æ®æä¾›è€…ï¼ˆHummingbot é£æ ¼ï¼‰
    market_data: *MarketDataProvider,

    /// è®¢å•æ‰§è¡Œå™¨ï¼ˆHummingbot Executorï¼‰
    executor: *OrderExecutor,

    /// ä»“ä½ç®¡ç†å™¨
    position_manager: *PositionManager,

    /// é£é™©ç®¡ç†å™¨
    risk_manager: *RiskManager,

    /// æŒ‡æ ‡ç®¡ç†å™¨
    indicator_manager: *IndicatorManager,

    /// äº¤æ˜“æ‰€æ¥å£
    exchange: IExchange,

    /// ç­–ç•¥é…ç½®
    config: StrategyConfig,
};
```

### ä¿¡å·ç±»å‹

```zig
/// äº¤æ˜“ä¿¡å·
pub const Signal = struct {
    /// ä¿¡å·ç±»å‹
    type: SignalType,

    /// äº¤æ˜“å¯¹
    pair: TradingPair,

    /// æ–¹å‘
    side: Side,

    /// å»ºè®®ä»·æ ¼
    price: Decimal,

    /// ä¿¡å·å¼ºåº¦ [0.0, 1.0]
    strength: f64,

    /// ä¿¡å·æ—¶é—´
    timestamp: Timestamp,

    /// é™„åŠ ä¿¡æ¯
    metadata: ?SignalMetadata,
};

pub const SignalType = enum {
    entry_long,      // åšå¤šå…¥åœº
    entry_short,     // åšç©ºå…¥åœº
    exit_long,       // å¤šå•å‡ºåœº
    exit_short,      // ç©ºå•å‡ºåœº
    hold,           // æŒæœ‰
};

pub const SignalMetadata = struct {
    reason: []const u8,           // ä¿¡å·åŸå› 
    indicators: []IndicatorValue, // ç›¸å…³æŒ‡æ ‡å€¼
};
```

### ç­–ç•¥å‚æ•°ï¼ˆç”¨äºä¼˜åŒ–ï¼‰

```zig
/// ç­–ç•¥å‚æ•°å®šä¹‰ï¼ˆå‚è€ƒ Freqtrade IntParameter/DecimalParameterï¼‰
pub const StrategyParameter = struct {
    name: []const u8,
    type: ParameterType,
    default_value: ParameterValue,
    range: ?ParameterRange,
    optimize: bool,  // æ˜¯å¦å‚ä¸ä¼˜åŒ–
};

pub const ParameterType = enum {
    integer,
    decimal,
    boolean,
    string,
};

pub const ParameterValue = union(ParameterType) {
    integer: i64,
    decimal: Decimal,
    boolean: bool,
    string: []const u8,
};

pub const ParameterRange = union(enum) {
    integer: struct { min: i64, max: i64, step: i64 },
    decimal: struct { min: Decimal, max: Decimal, step: Decimal },
};
```

---

## ğŸ“Š æŠ€æœ¯æŒ‡æ ‡åº“

### æŒ‡æ ‡æ¥å£

```zig
/// æŠ€æœ¯æŒ‡æ ‡æ¥å£
pub const IIndicator = struct {
    ptr: *anyopaque,
    vtable: *const VTable,

    pub const VTable = struct {
        /// è®¡ç®—æŒ‡æ ‡å€¼
        calculate: *const fn (*anyopaque, []Candle) anyerror![]Decimal,

        /// è·å–æŒ‡æ ‡åç§°
        getName: *const fn (*anyopaque) []const u8,

        /// è·å–æ‰€éœ€çš„æœ€å°èœ¡çƒ›æ•°
        getRequiredCandles: *const fn (*anyopaque) u32,
    };
};
```

### æ ¸å¿ƒæŒ‡æ ‡ï¼ˆPhase 1ï¼‰

#### 1. SMA (Simple Moving Average) - ç®€å•ç§»åŠ¨å¹³å‡

```zig
/// ç®€å•ç§»åŠ¨å¹³å‡
pub const SMA = struct {
    allocator: std.mem.Allocator,
    period: u32,

    pub fn init(allocator: std.mem.Allocator, period: u32) SMA {
        return .{
            .allocator = allocator,
            .period = period,
        };
    }

    /// è®¡ç®— SMA
    pub fn calculate(self: SMA, candles: []const Candle) ![]Decimal {
        if (candles.len < self.period) return error.InsufficientData;

        var result = try self.allocator.alloc(Decimal, candles.len);

        // å‰ period-1 ä¸ªå€¼ä¸º NaN
        for (0..self.period - 1) |i| {
            result[i] = Decimal.NaN;
        }

        // è®¡ç®—ç§»åŠ¨å¹³å‡
        for (self.period - 1..candles.len) |i| {
            var sum = Decimal.ZERO;
            for (i - self.period + 1..i + 1) |j| {
                sum = try sum.add(candles[j].close);
            }
            result[i] = try sum.div(try Decimal.fromInt(self.period));
        }

        return result;
    }
};
```

#### 2. EMA (Exponential Moving Average) - æŒ‡æ•°ç§»åŠ¨å¹³å‡

```zig
pub const EMA = struct {
    allocator: std.mem.Allocator,
    period: u32,

    pub fn calculate(self: EMA, candles: []const Candle) ![]Decimal {
        // Î± = 2 / (period + 1)
        const alpha = try Decimal.fromFloat(2.0).div(
            try Decimal.fromInt(self.period + 1)
        );

        // EMA[0] = Price[0]
        // EMA[t] = Î± Ã— Price[t] + (1 - Î±) Ã— EMA[t-1]

        var result = try self.allocator.alloc(Decimal, candles.len);
        result[0] = candles[0].close;

        for (1..candles.len) |i| {
            const term1 = try alpha.mul(candles[i].close);
            const term2 = try (try Decimal.ONE.sub(alpha)).mul(result[i - 1]);
            result[i] = try term1.add(term2);
        }

        return result;
    }
};
```

#### 3. RSI (Relative Strength Index) - ç›¸å¯¹å¼ºå¼±æŒ‡æ ‡

```zig
pub const RSI = struct {
    allocator: std.mem.Allocator,
    period: u32,

    pub fn calculate(self: RSI, candles: []const Candle) ![]Decimal {
        // è®¡ç®—ä»·æ ¼å˜åŒ–
        var gains = try self.allocator.alloc(Decimal, candles.len);
        var losses = try self.allocator.alloc(Decimal, candles.len);
        defer self.allocator.free(gains);
        defer self.allocator.free(losses);

        for (1..candles.len) |i| {
            const change = try candles[i].close.sub(candles[i - 1].close);
            if (change.isPositive()) {
                gains[i] = change;
                losses[i] = Decimal.ZERO;
            } else {
                gains[i] = Decimal.ZERO;
                losses[i] = try change.abs();
            }
        }

        // è®¡ç®—å¹³å‡æ”¶ç›Šå’Œå¹³å‡æŸå¤±ï¼ˆä½¿ç”¨ EMAï¼‰
        const avg_gain = try self.calculateEMA(gains);
        defer self.allocator.free(avg_gain);
        const avg_loss = try self.calculateEMA(losses);
        defer self.allocator.free(avg_loss);

        // RSI = 100 - (100 / (1 + RS))
        // RS = Average Gain / Average Loss
        var result = try self.allocator.alloc(Decimal, candles.len);
        for (self.period..candles.len) |i| {
            const rs = try avg_gain[i].div(avg_loss[i]);
            const rsi = try Decimal.fromInt(100).sub(
                try Decimal.fromInt(100).div(try Decimal.ONE.add(rs))
            );
            result[i] = rsi;
        }

        return result;
    }

    fn calculateEMA(self: RSI, values: []Decimal) ![]Decimal {
        // ... EMA è®¡ç®—é€»è¾‘
    }
};
```

#### 4. MACD (Moving Average Convergence Divergence)

```zig
pub const MACD = struct {
    allocator: std.mem.Allocator,
    fast_period: u32 = 12,
    slow_period: u32 = 26,
    signal_period: u32 = 9,

    pub const MACDResult = struct {
        macd_line: []Decimal,
        signal_line: []Decimal,
        histogram: []Decimal,
    };

    pub fn calculate(self: MACD, candles: []const Candle) !MACDResult {
        // MACD Line = EMA(12) - EMA(26)
        const fast_ema = try EMA.init(self.allocator, self.fast_period).calculate(candles);
        defer self.allocator.free(fast_ema);
        const slow_ema = try EMA.init(self.allocator, self.slow_period).calculate(candles);
        defer self.allocator.free(slow_ema);

        var macd_line = try self.allocator.alloc(Decimal, candles.len);
        for (0..candles.len) |i| {
            macd_line[i] = try fast_ema[i].sub(slow_ema[i]);
        }

        // Signal Line = EMA(MACD Line, 9)
        const signal_line = try EMA.init(self.allocator, self.signal_period).calculate(macd_line);

        // Histogram = MACD Line - Signal Line
        var histogram = try self.allocator.alloc(Decimal, candles.len);
        for (0..candles.len) |i| {
            histogram[i] = try macd_line[i].sub(signal_line[i]);
        }

        return MACDResult{
            .macd_line = macd_line,
            .signal_line = signal_line,
            .histogram = histogram,
        };
    }
};
```

#### 5. Bollinger Bands - å¸ƒæ—å¸¦

```zig
pub const BollingerBands = struct {
    allocator: std.mem.Allocator,
    period: u32 = 20,
    std_dev: f64 = 2.0,

    pub const BBResult = struct {
        upper: []Decimal,
        middle: []Decimal,
        lower: []Decimal,
    };

    pub fn calculate(self: BollingerBands, candles: []const Candle) !BBResult {
        // Middle Band = SMA(period)
        const middle = try SMA.init(self.allocator, self.period).calculate(candles);

        // è®¡ç®—æ ‡å‡†å·®
        var std = try self.calculateStdDev(candles, middle);
        defer self.allocator.free(std);

        // Upper Band = Middle + (std_dev Ã— std)
        // Lower Band = Middle - (std_dev Ã— std)
        var upper = try self.allocator.alloc(Decimal, candles.len);
        var lower = try self.allocator.alloc(Decimal, candles.len);

        const multiplier = try Decimal.fromFloat(self.std_dev);
        for (0..candles.len) |i| {
            const offset = try std[i].mul(multiplier);
            upper[i] = try middle[i].add(offset);
            lower[i] = try middle[i].sub(offset);
        }

        return BBResult{
            .upper = upper,
            .middle = middle,
            .lower = lower,
        };
    }

    fn calculateStdDev(self: BollingerBands, candles: []const Candle, mean: []Decimal) ![]Decimal {
        // ... æ ‡å‡†å·®è®¡ç®—
    }
};
```

### æŒ‡æ ‡ç®¡ç†å™¨

```zig
/// æŒ‡æ ‡ç®¡ç†å™¨ - ç¼“å­˜å’Œå¤ç”¨æŒ‡æ ‡è®¡ç®—ç»“æœ
pub const IndicatorManager = struct {
    allocator: std.mem.Allocator,
    cache: std.StringHashMap([]Decimal),

    pub fn getIndicator(
        self: *IndicatorManager,
        name: []const u8,
        candles: []Candle,
        calculate_fn: fn([]Candle) anyerror![]Decimal
    ) ![]Decimal {
        // æ£€æŸ¥ç¼“å­˜
        if (self.cache.get(name)) |cached| {
            return cached;
        }

        // è®¡ç®—å¹¶ç¼“å­˜
        const result = try calculate_fn(candles);
        try self.cache.put(name, result);
        return result;
    }
};
```

---

## ğŸ¤– å†…ç½®ç­–ç•¥

### 1. åŒå‡çº¿ç­–ç•¥ (Dual Moving Average)

```zig
/// åŒå‡çº¿ç­–ç•¥ - ç»å…¸è¶‹åŠ¿è·Ÿéšç­–ç•¥
pub const DualMAStrategy = struct {
    allocator: std.mem.Allocator,
    ctx: StrategyContext,

    // ç­–ç•¥å‚æ•°
    fast_period: u32 = 10,
    slow_period: u32 = 20,

    pub fn create(allocator: std.mem.Allocator) !IStrategy {
        const self = try allocator.create(DualMAStrategy);
        self.* = .{
            .allocator = allocator,
            .ctx = undefined,
        };

        return IStrategy{
            .ptr = self,
            .vtable = &vtable,
        };
    }

    fn initImpl(ptr: *anyopaque, ctx: StrategyContext) !void {
        const self: *DualMAStrategy = @ptrCast(@alignCast(ptr));
        self.ctx = ctx;
    }

    fn populateIndicatorsImpl(ptr: *anyopaque, candles: *Candles) !void {
        const self: *DualMAStrategy = @ptrCast(@alignCast(ptr));

        // è®¡ç®—å¿«é€Ÿ MA
        const fast_ma = try SMA.init(self.allocator, self.fast_period).calculate(candles.data);
        try candles.addIndicator("ma_fast", fast_ma);

        // è®¡ç®—æ…¢é€Ÿ MA
        const slow_ma = try SMA.init(self.allocator, self.slow_period).calculate(candles.data);
        try candles.addIndicator("ma_slow", slow_ma);
    }

    fn generateEntrySignalImpl(ptr: *anyopaque, candles: *Candles, index: usize) !?Signal {
        const self: *DualMAStrategy = @ptrCast(@alignCast(ptr));

        if (index < self.slow_period) return null;

        const fast_ma = candles.getIndicator("ma_fast") orelse return null;
        const slow_ma = candles.getIndicator("ma_slow") orelse return null;

        const prev_fast = fast_ma[index - 1];
        const prev_slow = slow_ma[index - 1];
        const curr_fast = fast_ma[index];
        const curr_slow = slow_ma[index];

        // é‡‘å‰ - å¿«çº¿ä¸Šç©¿æ…¢çº¿
        if (prev_fast.lte(prev_slow) and curr_fast.gt(curr_slow)) {
            return Signal{
                .type = .entry_long,
                .pair = self.ctx.config.pair,
                .side = .buy,
                .price = candles.data[index].close,
                .strength = 0.8,
                .timestamp = candles.data[index].timestamp,
                .metadata = null,
            };
        }

        // æ­»å‰ - å¿«çº¿ä¸‹ç©¿æ…¢çº¿
        if (prev_fast.gte(prev_slow) and curr_fast.lt(curr_slow)) {
            return Signal{
                .type = .entry_short,
                .pair = self.ctx.config.pair,
                .side = .sell,
                .price = candles.data[index].close,
                .strength = 0.8,
                .timestamp = candles.data[index].timestamp,
                .metadata = null,
            };
        }

        return null;
    }

    fn generateExitSignalImpl(ptr: *anyopaque, candles: *Candles, pos: Position) !?Signal {
        // åŒå‡çº¿ç­–ç•¥: åå‘ä¿¡å·å³ä¸ºå‡ºåœºä¿¡å·
        const entry_signal = try generateEntrySignalImpl(ptr, candles, candles.data.len - 1);

        if (entry_signal) |signal| {
            // å¦‚æœæŒæœ‰å¤šå•ï¼Œé‡åˆ°æ­»å‰åˆ™å¹³ä»“
            if (pos.side == .long and signal.type == .entry_short) {
                return Signal{
                    .type = .exit_long,
                    .pair = pos.pair,
                    .side = .sell,
                    .price = signal.price,
                    .strength = signal.strength,
                    .timestamp = signal.timestamp,
                    .metadata = null,
                };
            }

            // å¦‚æœæŒæœ‰ç©ºå•ï¼Œé‡åˆ°é‡‘å‰åˆ™å¹³ä»“
            if (pos.side == .short and signal.type == .entry_long) {
                return Signal{
                    .type = .exit_short,
                    .pair = pos.pair,
                    .side = .buy,
                    .price = signal.price,
                    .strength = signal.strength,
                    .timestamp = signal.timestamp,
                    .metadata = null,
                };
            }
        }

        return null;
    }

    fn getMetadataImpl(ptr: *anyopaque) StrategyMetadata {
        const self: *DualMAStrategy = @ptrCast(@alignCast(ptr));

        return StrategyMetadata{
            .name = "Dual Moving Average",
            .version = "1.0.0",
            .author = "zigQuant",
            .description = "Classic dual MA crossover strategy",
            .strategy_type = .trend_following,
            .timeframe = .m15,
            .startup_candle_count = self.slow_period,
            .minimal_roi = MinimalROI{
                .targets = &[_]MinimalROI.ROITarget{
                    .{ .time_minutes = 0, .profit_ratio = try Decimal.fromFloat(0.02) },
                    .{ .time_minutes = 30, .profit_ratio = try Decimal.fromFloat(0.01) },
                },
            },
            .stoploss = try Decimal.fromFloat(-0.05),  // -5%
            .trailing_stop = null,
        };
    }

    const vtable = IStrategy.VTable{
        .init = initImpl,
        .deinit = deinitImpl,
        .populateIndicators = populateIndicatorsImpl,
        .generateEntrySignal = generateEntrySignalImpl,
        .generateExitSignal = generateExitSignalImpl,
        .calculatePositionSize = calculatePositionSizeImpl,
        .getParameters = getParametersImpl,
        .getMetadata = getMetadataImpl,
    };
};
```

### 2. RSI å‡å€¼å›å½’ç­–ç•¥

```zig
/// RSI å‡å€¼å›å½’ç­–ç•¥ - è¶…ä¹°è¶…å–åè½¬
pub const RSIMeanReversionStrategy = struct {
    // å‚æ•°
    rsi_period: u32 = 14,
    oversold_threshold: u32 = 30,
    overbought_threshold: u32 = 70,

    // å…¥åœºä¿¡å·: RSI < 30 (è¶…å–) -> åšå¤š
    // å‡ºåœºä¿¡å·: RSI > 50 (å›å½’ä¸­ä½) -> å¹³ä»“
};
```

### 3. å¸ƒæ—å¸¦çªç ´ç­–ç•¥

```zig
/// å¸ƒæ—å¸¦çªç ´ç­–ç•¥
pub const BollingerBreakoutStrategy = struct {
    // å‚æ•°
    bb_period: u32 = 20,
    bb_std_dev: f64 = 2.0,

    // å…¥åœºä¿¡å·: ä»·æ ¼çªç ´ä¸Šè½¨ -> åšå¤š
    // å‡ºåœºä¿¡å·: ä»·æ ¼å›åˆ°ä¸­è½¨ -> å¹³ä»“
};
```

---

## â®ï¸ å›æµ‹å¼•æ“

### å›æµ‹å¼•æ“æ¶æ„

```zig
/// å›æµ‹å¼•æ“ - ä½¿ç”¨å†å²æ•°æ®éªŒè¯ç­–ç•¥
pub const BacktestEngine = struct {
    allocator: std.mem.Allocator,
    logger: Logger,

    /// å†å²æ•°æ®æä¾›è€…
    data_feed: *HistoricalDataFeed,

    /// äº‹ä»¶æ¨¡æ‹Ÿå™¨
    event_simulator: *EventSimulator,

    /// æ€§èƒ½åˆ†æå™¨
    analyzer: *PerformanceAnalyzer,

    pub fn run(
        self: *BacktestEngine,
        strategy: IStrategy,
        config: BacktestConfig,
    ) !BacktestResult {
        // 1. åŠ è½½å†å²æ•°æ®
        const candles = try self.data_feed.load(config.pair, config.timeframe, config.start_time, config.end_time);
        defer candles.deinit();

        // 2. åˆå§‹åŒ–ç­–ç•¥
        try strategy.populateIndicators(candles);

        // 3. é€æ¡æ¨¡æ‹Ÿ
        var trades = std.ArrayList(Trade).init(self.allocator);
        defer trades.deinit();

        var current_position: ?Position = null;

        for (candles.data, 0..) |candle, i| {
            // ç”Ÿæˆä¿¡å·
            const signal = try strategy.generateEntrySignal(candles, i);

            if (signal) |sig| {
                if (current_position == null) {
                    // å¼€ä»“
                    const size = try strategy.calculatePositionSize(sig, account);
                    current_position = Position{
                        .pair = sig.pair,
                        .side = if (sig.side == .buy) .long else .short,
                        .size = size,
                        .entry_price = sig.price,
                        .timestamp = sig.timestamp,
                    };
                }
            }

            // æ£€æŸ¥å‡ºåœºä¿¡å·
            if (current_position) |pos| {
                const exit_signal = try strategy.generateExitSignal(candles, pos);
                if (exit_signal) |exit_sig| {
                    // å¹³ä»“
                    const trade = Trade{
                        .entry_time = pos.timestamp,
                        .exit_time = exit_sig.timestamp,
                        .entry_price = pos.entry_price,
                        .exit_price = exit_sig.price,
                        .size = pos.size,
                        .side = pos.side,
                        .pnl = try self.calculatePnL(pos, exit_sig.price),
                    };
                    try trades.append(trade);
                    current_position = null;
                }
            }
        }

        // 4. åˆ†æç»“æœ
        return try self.analyzer.analyze(trades.items);
    }
};

/// å›æµ‹é…ç½®
pub const BacktestConfig = struct {
    pair: TradingPair,
    timeframe: Timeframe,
    start_time: Timestamp,
    end_time: Timestamp,
    initial_capital: Decimal,
    commission_rate: Decimal,
};

/// å›æµ‹ç»“æœ
pub const BacktestResult = struct {
    total_trades: u32,
    winning_trades: u32,
    losing_trades: u32,

    total_profit: Decimal,
    total_loss: Decimal,
    net_profit: Decimal,

    win_rate: f64,
    profit_factor: f64,
    sharpe_ratio: f64,
    max_drawdown: f64,

    trades: []Trade,
};
```

---

## ğŸ”§ å‚æ•°ä¼˜åŒ–

### ç½‘æ ¼æœç´¢ä¼˜åŒ–å™¨

```zig
/// ç½‘æ ¼æœç´¢ä¼˜åŒ–å™¨ - éå†æ‰€æœ‰å‚æ•°ç»„åˆ
pub const GridSearchOptimizer = struct {
    allocator: std.mem.Allocator,
    backtest_engine: *BacktestEngine,

    pub fn optimize(
        self: *GridSearchOptimizer,
        strategy_factory: fn ([]ParameterValue) IStrategy,
        params: []StrategyParameter,
        config: BacktestConfig,
    ) !OptimizationResult {
        var best_result: ?BacktestResult = null;
        var best_params: ?[]ParameterValue = null;

        // ç”Ÿæˆæ‰€æœ‰å‚æ•°ç»„åˆ
        const combinations = try self.generateCombinations(params);
        defer self.freeCombinations(combinations);

        for (combinations) |param_values| {
            // åˆ›å»ºç­–ç•¥å®ä¾‹
            const strategy = strategy_factory(param_values);
            defer strategy.deinit();

            // è¿è¡Œå›æµ‹
            const result = try self.backtest_engine.run(strategy, config);

            // æ¯”è¾ƒç»“æœ
            if (best_result == null or result.sharpe_ratio > best_result.?.sharpe_ratio) {
                best_result = result;
                best_params = try self.allocator.dupe(ParameterValue, param_values);
            }
        }

        return OptimizationResult{
            .best_params = best_params.?,
            .best_result = best_result.?,
        };
    }
};
```

---

## ğŸ“… å®æ–½è®¡åˆ’

### Week 1: ç­–ç•¥æ¥å£ + æŠ€æœ¯æŒ‡æ ‡åº“

**ç›®æ ‡**: å»ºç«‹ç­–ç•¥æ¡†æ¶åŸºç¡€

**ä»»åŠ¡**:
1. âœ… å®ç° IStrategy æ¥å£å’Œ VTable
2. âœ… å®ç° StrategyContext å’Œç›¸å…³ç±»å‹
3. âœ… å®ç° 5 ä¸ªæ ¸å¿ƒæŒ‡æ ‡: SMA, EMA, RSI, MACD, Bollinger Bands
4. âœ… å®ç° IndicatorManagerï¼ˆç¼“å­˜ä¼˜åŒ–ï¼‰
5. âœ… ç¼–å†™å•å…ƒæµ‹è¯•
6. âœ… æ›´æ–°æ–‡æ¡£

**äº¤ä»˜ç‰©**:
- `src/strategy/interface.zig`
- `src/strategy/context.zig`
- `src/strategy/types.zig`
- `src/strategy/indicators/` (5ä¸ªæŒ‡æ ‡)
- `docs/features/strategy/` (å®Œæ•´æ–‡æ¡£)
- å•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 85%

### Week 2: å†…ç½®ç­–ç•¥ + å›æµ‹å¼•æ“

**ç›®æ ‡**: å®ç°å¯å·¥ä½œçš„ç­–ç•¥å’ŒéªŒè¯èƒ½åŠ›

**ä»»åŠ¡**:
1. âœ… å®ç°åŒå‡çº¿ç­–ç•¥
2. âœ… å®ç° RSI å‡å€¼å›å½’ç­–ç•¥
3. âœ… å®ç°å¸ƒæ—å¸¦çªç ´ç­–ç•¥
4. âœ… å®ç°å›æµ‹å¼•æ“æ ¸å¿ƒ
5. âœ… å®ç°æ€§èƒ½åˆ†æå™¨
6. âœ… é›†æˆæµ‹è¯•ï¼ˆä½¿ç”¨å†å²æ•°æ®ï¼‰
7. âœ… æ›´æ–°æ–‡æ¡£

**äº¤ä»˜ç‰©**:
- `src/strategy/builtin/` (3ä¸ªç­–ç•¥)
- `src/backtest/` (å›æµ‹å¼•æ“)
- `docs/features/backtest/` (å›æµ‹æ–‡æ¡£)
- é›†æˆæµ‹è¯•é€šè¿‡

### Week 3: å‚æ•°ä¼˜åŒ– + å®Œå–„

**ç›®æ ‡**: æ·»åŠ ä¼˜åŒ–èƒ½åŠ›å’Œå®Œå–„åŠŸèƒ½

**ä»»åŠ¡**:
1. âœ… å®ç°ç½‘æ ¼æœç´¢ä¼˜åŒ–å™¨
2. âœ… å®ç°ç­–ç•¥æ€§èƒ½å¯¹æ¯”å·¥å…·
3. âœ… æ·»åŠ æ›´å¤šæŠ€æœ¯æŒ‡æ ‡ï¼ˆå¯é€‰ï¼‰
4. âœ… CLI é›†æˆï¼ˆstrategy backtest, strategy optimize å‘½ä»¤ï¼‰
5. âœ… æ€§èƒ½ä¼˜åŒ–
6. âœ… å®Œæ•´æµ‹è¯•å’Œæ–‡æ¡£
7. âœ… ç¤ºä¾‹å’Œæ•™ç¨‹

**äº¤ä»˜ç‰©**:
- `src/optimizer/` (ä¼˜åŒ–å™¨)
- `src/cli/strategy.zig` (CLI å‘½ä»¤)
- `examples/05_strategy_backtest.zig`
- `examples/06_strategy_optimize.zig`
- å®Œæ•´æ–‡æ¡£å’Œæ•™ç¨‹

---

## ğŸ“š å‚è€ƒèµ„æº

- **Hummingbot V2**: [Architecture](https://hummingbot.org/v2-strategies/)
- **Freqtrade**: [Strategy Customization](https://www.freqtrade.io/en/stable/strategy-customization/)
- **Technical Indicators**: [TA-Lib](https://ta-lib.org/)

---

## âœ… æˆåŠŸæ ‡å‡†

### åŠŸèƒ½å®Œæ•´æ€§
- [ ] IStrategy æ¥å£å®Œæ•´å®ç°
- [ ] è‡³å°‘ 5 ä¸ªæŠ€æœ¯æŒ‡æ ‡å¯ç”¨
- [ ] è‡³å°‘ 3 ä¸ªå†…ç½®ç­–ç•¥å¯ç”¨
- [ ] å›æµ‹å¼•æ“åŠŸèƒ½å®Œæ•´
- [ ] å‚æ•°ä¼˜åŒ–åŠŸèƒ½å¯ç”¨

### æ€§èƒ½æŒ‡æ ‡
- [ ] ç­–ç•¥æ‰§è¡Œå»¶è¿Ÿ < 1ms
- [ ] å›æµ‹é€Ÿåº¦ > 1000 candles/s
- [ ] é›¶å†…å­˜æ³„æ¼
- [ ] æµ‹è¯•è¦†ç›–ç‡ > 85%

### æ–‡æ¡£è´¨é‡
- [ ] æ‰€æœ‰å…¬å…± API æœ‰æ–‡æ¡£
- [ ] æä¾›å®Œæ•´ä½¿ç”¨ç¤ºä¾‹
- [ ] æä¾›ç­–ç•¥å¼€å‘æ•™ç¨‹
- [ ] API å‚è€ƒå®Œæ•´

---

**åˆ›å»ºæ—¶é—´**: 2025-12-25
**é¢„è®¡å®Œæˆ**: 3 å‘¨
**çŠ¶æ€**: è®¾è®¡é˜¶æ®µ âœ…

ğŸ‰ Generated with [Claude Code](https://claude.com/claude-code)
