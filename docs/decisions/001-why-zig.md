# ADR-001: 选择 Zig 作为实现语言

**状态**: ✅ 已接受
**日期**: 2025-01-20
**决策者**: 项目发起人
**相关 Story**: 项目初始化

---

## 背景 (Context)

我们需要选择一门语言来实现高性能量化交易框架，具备以下需求：

1. **性能要求**:
   - 低延迟 (订单延迟 < 10ms P99)
   - 高吞吐 (>100K 消息/秒)
   - 内存效率高

2. **安全要求**:
   - 内存安全
   - 无数据竞争
   - 可靠的错误处理

3. **开发效率**:
   - 易于维护
   - 编译时错误检测
   - 良好的工具链

4. **约束条件**:
   - 需要与交易所 API 集成
   - 需要处理高精度数值计算
   - 需要跨平台支持

---

## 决策 (Decision)

**我们决定使用 Zig 语言实现 ZigQuant 框架**

Zig 是一门现代系统编程语言，提供：
- 手动内存管理 + 编译时安全检查
- 零成本抽象
- 显式错误处理
- 简洁的语法
- 优秀的 C 互操作性

---

## 备选方案 (Alternatives Considered)

### 方案 A: Rust

**描述**: 使用 Rust 实现，Rust 是内存安全的系统编程语言。

**优点**:
- ✅ 内存安全保证 (所有权系统)
- ✅ 强大的类型系统
- ✅ 丰富的生态 (crates.io)
- ✅ 优秀的并发支持
- ✅ 已有成熟的量化库

**缺点**:
- ❌ 学习曲线陡峭 (lifetime, borrow checker)
- ❌ 编译时间长
- ❌ 错误信息复杂
- ❌ 运行时包含 panic unwinding 开销

**为什么不选**: Rust 的复杂性会降低开发效率，对于量化交易这种需要快速迭代的场景，Zig 的简洁性更有优势。

---

### 方案 B: C++

**描述**: 使用现代 C++ (C++20) 实现。

**优点**:
- ✅ 极致性能
- ✅ 丰富的库生态
- ✅ 大量现有代码可复用
- ✅ 广泛的工具支持

**缺点**:
- ❌ 内存安全问题 (UB, 悬垂指针)
- ❌ 构建系统复杂 (CMake 地狱)
- ❌ 语言特性过多，难以约束
- ❌ 编译时间极长
- ❌ 异常处理开销

**为什么不选**: C++ 的复杂性和内存安全问题是致命缺陷，维护成本太高。

---

### 方案 C: Go

**描述**: 使用 Go 实现，简单高效的并发语言。

**优点**:
- ✅ 简洁易学
- ✅ 出色的并发支持 (goroutine)
- ✅ 快速编译
- ✅ 良好的工具链
- ✅ 自动垃圾回收

**缺点**:
- ❌ GC 延迟不可控 (对低延迟场景致命)
- ❌ 缺少泛型 (1.18+ 才支持)
- ❌ 错误处理冗长
- ❌ 性能不如系统语言

**为什么不选**: GC 暂停会导致延迟尖刺，无法满足低延迟要求。

---

### 方案 D: Python (继续使用 Freqtrade)

**描述**: 直接使用 Python + Freqtrade。

**优点**:
- ✅ 生态成熟
- ✅ 开发速度快
- ✅ 已有完整功能
- ✅ 易于原型验证

**缺点**:
- ❌ 性能差 (GIL 限制)
- ❌ 运行时类型错误
- ❌ 内存占用高
- ❌ 不适合高频交易

**为什么不选**: 性能瓶颈明显，无法满足高性能需求。

---

## 结果 (Consequences)

### 正面影响
- ✅ **性能**: 接近 C 的性能，无 GC 开销
- ✅ **安全**: 编译时内存安全检查，显式错误处理
- ✅ **简洁**: 语法简洁，易于维护
- ✅ **控制**: 完全控制内存布局和分配
- ✅ **互操作**: 轻松调用 C 库 (OpenSSL, SQLite)
- ✅ **工具链**: 内置构建系统和包管理

### 负面影响
- ⚠️ **生态不成熟**: 第三方库较少，需要自己实现更多
- ⚠️ **社区规模**: 社区比 Rust/Go 小
- ⚠️ **学习资源**: 文档和教程相对较少
- ⚠️ **人才储备**: 懂 Zig 的开发者较少

### 风险
- ⚠️ **语言稳定性**: Zig 尚未发布 1.0
  - **缓解**: 使用稳定的 master 版本，关注语言变更

- ⚠️ **库缺失**: 可能需要自己实现某些功能
  - **缓解**: 利用 C 互操作调用成熟库

- ⚠️ **团队能力**: 团队需要学习 Zig
  - **缓解**: Zig 语法简单，学习曲线平缓

---

## 实施计划 (Implementation)

1. ✅ **Phase 1**: 搭建基础设施
   - 项目结构
   - 构建系统
   - CI/CD

2. 🚧 **Phase 2**: 实现核心类型
   - Decimal 类型
   - 时间处理
   - 错误系统

3. 📋 **Phase 3**: 集成外部库
   - HTTP/WebSocket (zap)
   - SQLite
   - JSON 解析

4. 📋 **Phase 4**: 实现业务逻辑
   - 交易所连接器
   - 订单管理
   - 策略框架

**预计工作量**: 持续进行

---

## 验证标准 (Validation)

- [x] 能实现高精度数值计算
- [ ] 订单延迟 < 10ms (P99)
- [ ] WebSocket 吞吐 > 100K msg/s
- [ ] 内存使用 < 500MB
- [ ] 无内存泄漏
- [ ] 无数据竞争
- [ ] 能稳定运行 30 天+

---

## 性能对比基准

| 语言 | 延迟 (P99) | 吞吐 | 内存 | 开发效率 |
|------|-----------|------|------|---------|
| Zig  | < 10ms    | ★★★★★ | ★★★★★ | ★★★★☆ |
| Rust | < 10ms    | ★★★★★ | ★★★★★ | ★★★☆☆ |
| C++  | < 5ms     | ★★★★★ | ★★★★★ | ★★☆☆☆ |
| Go   | 10-50ms   | ★★★★☆ | ★★★☆☆ | ★★★★★ |
| Python | >100ms  | ★★☆☆☆ | ★★☆☆☆ | ★★★★★ |

---

## 相关资源

- [Zig 官网](https://ziglang.org/)
- [Zig 学习资源](https://ziglearn.org/)
- [Zig 标准库文档](https://ziglang.org/documentation/master/std/)
- [为什么选择 Zig](https://ziglang.org/#Why-Zig)

---

## 备注

这个决策是在项目初期做出的，随着项目发展，可能需要重新评估。如果 Zig 的某些限制成为瓶颈，我们会考虑部分模块使用其他语言（如性能关键路径用 C）。

---

*Last updated: 2025-01-22*
